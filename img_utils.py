#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Image deformation using moving least squares.

    * Affine deformation
    * Similarity deformation
    * Rigid deformation

For more details please refer to the Chinese documentation:

    ./doc/Image Deformation.pdf

or the original paper:

    Image deformation using moving least squares
    Schaefer, Mcphail, Warren.

Note:
    In the original paper, the author missed the weight w_j in formular (5).
    In addition, all the formulars in section 2.1 miss the w_j.
    And I have corrected this point in my documentation.

@author: Jian-Wei ZHANG
@email: zjw.cs@zju.edu.cn
@date: 2017/8/8
@update: 2020/9/25: No need for so-called inverse transformation. Just transform target pixels to the corresponding source pixels.
@update: 2021/7/14: Optimize memory usage. Now a 2000x2000 image with 64 control points spend about 4.2GB memory. (20GB in the previous version)
@update: 2021/12/24: Fix a bug of nan values in `mls_rigid_deformation()`. (see issue #13)
"""

import numpy as np
import numexpr as ne

np.seterr(divide='ignore', invalid='ignore')


def mls_deformation(vy, vx, p, q, alpha=1.0, eps=1e-8, solver=None):
    """ Deformation

    Parameters
    ----------
    vy, vx: ndarray
        coordinate grid, generated by np.meshgrid(gridX, gridY)
    p: ndarray
        an array with size [n, 2], original control points, in (y, x) formats
    q: ndarray
        an array with size [n, 2], final control points, in (y, x) formats
    alpha: float
        parameter used by weights
    eps: float
        epsilon

    Return
    ------
        A deformed image.
    """
    # Exchange p and q and hence we transform destination pixels to the corresponding source pixels.
    p, q = q, p

    grow = vx.shape[0]  # grid rows
    gcol = vy.shape[1]  # grid cols
    ctrls = p.shape[0]  # control points

    # Precompute
    _p = p.reshape(1, 1, ctrls, 1, 2)
    # 强制（逻辑）类型转换？
    _p.dtype = 'complex128'
    vx = np.expand_dims(vx, (2, 3, 4))
    vy = np.expand_dims(vy, (2, 3, 4))

    w = ne.evaluate('1 / (real(abs(_p - complex(vx, vy))) ** 2 + eps) ** alpha')
    w /= np.sum(w, axis=2, keepdims=True)

    _pstar = ne.evaluate('sum(w * _p, axis=2)')
    _pstar = np.expand_dims(_pstar, 2)

    # Calculate q
    _q = q.reshape(1, 1, ctrls, 1, 2)
    _q.dtype = 'complex128'
    _qstar = ne.evaluate('sum(w * _q, axis=2)')
    _qstar = np.expand_dims(_qstar, 2)

    # Get final image transfomer -- 3-D array
    transformers = solver(w, _q, _qstar, _p, _pstar, vx, vy)
    transformers.dtype = 'float64'     # 进化回实数域？

    # Removed the points outside the border
    np.clip(transformers, 0, (grow - 1, gcol - 1), out=transformers)
    transformers.shape = grow, gcol, 2

    return transformers.astype(np.int16)


def affine_solver(_w, _q, _qstar, _p, _pstar, vx, vy):
    grow, gcol = _w.shape[:2]
    vphat = ne.evaluate('complex(vx, vy) - _pstar')
    vphat.dtype = 'float64'
    _q.dtype = 'float64'
    _qstar.dtype = 'float64'
    _p.dtype = 'float64'
    _pstar.dtype = 'float64'
    _phat = _p - _pstar
    _phatT = _phat.reshape(grow, gcol, -1, 2, 1)
    _pTwp = ne.evaluate('sum(_phatT * _w * _phat, axis=2)')     # [grow, gcol, 1,     2, 2]
    _pTwq = ne.evaluate('sum(_phatT * _w * (_q - _qstar), axis=2)')     # [grow, gcol, 1,     2, 2]
    _M = np.linalg.inv(_pTwp) @ _pTwq                           # [grow, gcol, 1, 2, 2]
    _M.shape = grow, gcol, 1, 2, 2
    return vphat @ _M + _qstar


def similarity_solver(w, _q, _qstar, _p, _pstar, vx, vy):
    _M = ne.evaluate('sum(conj(_p - _pstar) * w * (_q - _qstar), axis=2)')
    mu = ne.evaluate('sum(w * real(abs(_p - _pstar) ** 2), axis=2)')
    _M = np.expand_dims(_M, 2)
    mu = np.expand_dims(mu, 2)
    return ne.evaluate('(complex(vx, vy) - _pstar) * (_M / mu) + _qstar')


def rigid_solver(w, _q, _qstar, _p, _pstar, vx, vy):
    _M = ne.evaluate('sum(conj(_p - _pstar) * w * (_q - _qstar), axis=2)')
    _M = np.expand_dims(_M, 2)
    return ne.evaluate('(complex(vx, vy) - _pstar) * (_M / abs(_M)) + _qstar')


def mls_affine_deformation(vy, vx, p, q, alpha=1.0, eps=1e-8):
    return mls_deformation(vy, vx, p, q, alpha=alpha, eps=eps, solver=affine_solver)


def mls_similarity_deformation(vy, vx, p, q, alpha=1.0, eps=1e-8):
    return mls_deformation(vy, vx, p, q, alpha=alpha, eps=eps, solver=similarity_solver)


def mls_rigid_deformation(vy, vx, p, q, alpha=1.0, eps=1e-8):
    return mls_deformation(vy, vx, p, q, alpha=alpha, eps=eps, solver=rigid_solver)
